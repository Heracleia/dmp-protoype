%% Extract DMP parameters

%% Load the data
load saveddata

%% Establish some of the variables

x=saveddata.x;
dx=saveddata.vx;
ddx=saveddata.ax;
x0=x(1);
gx=x(end);

dtx=diff(saveddata.times);
dtx=dtx(1);

y=saveddata.y;
dy=saveddata.vy;
ddy=saveddata.ay;
y0=y(1);
gy=y(end);

time=saveddata.times;

%% Normalize the time vector from zero to to one

time=time-time(1);

%% Parameters of the DMP

par.ng=30; % Number of Gaussians

h=1;  
par.h=ones(1,par.ng)*(h); % width of the Gaussians 


par.s=1; % Init of phase
par.as=1; % Decay of s phase var
par.tau=max(time); % Time scaling

par.K=1; % K gain
par.D=1; % D gain

%% Start training the DMP

len=length(time);

% ftarget calculation
stime=[];
sE_x=[];
sE_y=[];

for i=1:len
    
    t=time(i);
    s=exp((-1*par.as*t)/par.tau);
    stime=[stime s];
    
    % fdemonstration=ftarget
    ftarget_x(i)= (-1*par.K*(gx-x(i))+par.D*dx(i)+par.tau*ddx(i))/(gx-x0);
    ftarget_y(i)= (-1*par.K*(gy-y(i))+par.D*dy(i)+par.tau*ddy(i))/(gy-y0);
    
    sE_x=[sE_x; s*(gx-x0)];
    sE_y=[sE_y; s*(gy-y0)];
    
end

% centers of gaussian are placed even in s time
% gaussian centers are distributed evenly in s axis.
incr=(max(stime)-min(stime))/(par.ng-1);
c=min(stime):incr:max(stime);
lrc=fliplr(c);
ctime=(-1*par.tau*log(lrc))/par.as;
d=diff(c);
c=c/d(1); % normalize for exp correctness
par.c=c;

% Regression 
for i=1:par.ng
    psV_x=[];   
    psV_y=[];   
    for j=1:len
          psV_x=[psV_x psiF(par.h,par.c,stime(j)/d(1),i)];
          psV_y=[psV_y psiF(par.h,par.c,stime(j)/d(1),i)];
    end
    %Locally Weighted Learning
    w_x(i)=(transpose(sE_x)*diag(psV_x)*transpose(ftarget_x))/(transpose(sE_x)*diag(psV_x)*sE_x);
    w_y(i)=(transpose(sE_y)*diag(psV_y)*transpose(ftarget_y))/(transpose(sE_y)*diag(psV_y)*sE_y);
end

%% Store the results

r=par;
r.len=len;
r.time=time;
r.stime=stime;
r.ftarget_x=ftarget_x;
r.ftarget_y=ftarget_y;
r.w_x=w_x;
r.w_y=w_y;
r.x0=x0;
r.y0=y0;
r.gx=gx;
r.gy=gy;
r.d1=d(1);
r.dt=dtx;
r.ctime=ctime;
r.penWidth1=2;
r.penWidth2=2;


%% Generate again the 

